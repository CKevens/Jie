>   漏洞扫描器之 SQL 注入检测, 本篇参阅了大量 v1ll4n 师傅的文章

# SQl 注入

提到 SQL 注入，那就离不开一个神器 [sqlmap](https://github.com/sqlmapproject/sqlmap)。 该漏洞模块检测打算从 [sqlmap](https://github.com/sqlmapproject/sqlmap) 中抽离出关于SQL注入检测的部分，使用 go 实现一遍。

# SQLMAP部分源码阅读

sqlmap 首先会对目标进行连接性检测，然后发送可能被拦截的 payload 进行 waf 检测(这一块可以作为整体扫描器的一个入口检测)。然后就是我们要关注的核心功能，SQL 注入的检测。

## 页面相似度

waf 检测中除了关键字匹配外,还会进行页面相似度算法进行匹配，并且会区分页面是否为动态的(第一次和第二次同样访问页面相似度小于 0.98)，也就是每次访问页面的某些元素会变,比如广告。

当 sqlmap 认为这个页面是一个动态页面时，会尝试寻找该页面的动态内容(`findDynamicContent`),找到后默认会将动态内容的前 20 字符和后 20 字符做一个标记，方便后面对比判断时将动态内容移除。

-   相似度比较有第三方库可供我们使用[strsim](github.com/antlabs/strsim)

-   标记动态内容，目前是粗暴的对比页面内容，将不同点提取出来,然后标记

前期准备这一块的实现还是很简单的，难点在于下面的检测方面。

## 参数预处理和动态参数检查



## 注入检测

sqlmap 主要有两种检测(`lib/controller/controller.py`)

-   启发式检测，对目标参数 sql 注入做一个初步的判断(第一个红框)
-   注入检测(第二个红框)

![image-20230207205442610](images/image-20230207205442610.png)

### 1. 启发式检测

这个过程就是寻找闭合 sql 语句的一个行为，sqlmap 会根据参数类型采取不同的闭合方式，比如数字采用无闭合方式，字符串采用常见的单引号闭合

```python
# Alphabet used for heuristic checks
HEURISTIC_CHECK_ALPHABET = ('"', '\'', ')', '(', ',', '.')
```





启发式检查完后，会执行 XSS 和 FI 检测

-   检测 XSS 的方法其实就是检查 `"<'\">"`，是否出现在了结果中。作为扩展，我们可以在此检查是否随机字符串还在页面中，从而判断是否存在 XSS 的迹象。
-   检测 FI（文件包含），就是检测结果中是否包含了 `include/require` 等报错信息，这些信息是通过特定正则表达式来匹配检测的。

### 2. 注入检测

#### 布尔盲注


#### 报错注入
读取 errors.xml 字典,进行匹配就好了

#### 时间盲注
首先计算了访问正常页面的响应时间，计算公式为:五次样本内平均响应时间 + 7 * 样本标准差，这样就可以保证过滤掉 99.99% 的无延迟请求。

>标准差和方差一样都是用于衡量样本的离散程度的量，那么为什么要有标准差呢？因为方差和样本的“量纲”不一样，换句话说不在一个层次。怎么理解这个层次呢，从公式看方差是样本与均值的差的平方和的平均，这里有一个平方运算，这是导致量纲不在同一个层次的原因。
>
>比如两个集合 [0，8，12，20]和 [8，9，11，12]，两个集合的均值都是10，两个集合的方差分别是：69.33和3.33；计算两者的标准差分别是：8.3和1.8。数字越大代表越离散，从数值上看方差和标准差的量纲差别就很明显了，而标准差更好的在量纲上与样本集合保持同步。这就是“标准”的意义了。

>为什么要加上 7 倍的标准差？
>
>因为正常情况下，响应时间的分布是符合正态分布的，而正态分布的 99.99% 的数据都在 7 倍的标准差之内，所以这里就是为了过滤掉 99.99% 的无延迟请求。
>
>Copilot 告诉我的, 还挺好使，哈哈

代码实现

```go
timeRec 是一个记录五次访问时间的数组
mean(timeRec) + 7*std(timeRec)

// 期望,也就是平均响应时间
func mean(v []float64) float64 {
	var res float64 = 0
	var n = len(v)
	for i := 0; i < n; i++ {
		res += v[i]
	}
	return res / float64(n)
}

// 方差
func variance(v []float64) float64 {
	var res float64 = 0
	var m = mean(v)
	var n = len(v)
	for i := 0; i < n; i++ {
		res += (v[i] - m) * (v[i] - m)
	}
	return res / float64(n-1)
}

// 标准差
func std(v []float64) float64 {
	return math.Sqrt(variance(v))
}
```





#### UNION 注入

猜解列数

核心思想就是 **利用与模版页面比较的内容相似度寻找最最不同的那一个请求**。

猜解输出点在列中位置


# 参考

http://wjlshare.com/archives/1733

https://mp.weixin.qq.com/s/G_0tXDo_BWo_niR2afg0WQ

https://zhuanlan.zhihu.com/p/44157153

https://zhuanlan.zhihu.com/p/45291193